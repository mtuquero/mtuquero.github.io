---
layout: essay
type: essay
title: "Effort Estimation and Tracking"
date: 2025-4-12
published: true
labels:

---

# Effort Estimation and Tracking

<img src="img/E4C5C3FC-9652-4C64-B198-E849D91F54B3.png" 
     alt="Effort Tracking" 
     width="200px" 
     style="float:left; margin-right:1em; border-radius:8px;">



## Approach to Time Estimation
I estimated my time through the WODs and my confidence when it came to the issue I was working on. I also usually overestimated my coding effort because I believed it was better to account for potential bugs, integration issues, or refactoring that might be needed. This helped ensure I had enough time to complete tasks without rushing, even when the actual coding effort ended up being lower.

## Value of Pre-Planning Effort
Although my estimates were sometimes inaccurate, pre-planning provided significant benefits. Estimating in advance allowed me to allocate my work schedule more effectively, ensuring I could prioritize tasks and reduce the risk of bottlenecks. For example, when working on user authentication features, I allocated extra time for email validation and password confirmation, which helped me avoid last-minute delays. Tracking my coding effort also revealed how long debugging and problem-solving actually took, which was often longer than initially expected. Additionally, using AI tools like Copilot sometimes accelerated coding but also required extra effort for reviewing, debugging, and integrating generated code. Pre-planning made it easier to account for these variations and adjust timelines accordingly.

## Usefulness of Tracking Actual Effort
Tracking actual effort was extremely informative, even though it could be challenging to maintain consistently. Recording time helped me see patterns in my workflow, such as which types of tasks took longer than expected and which were completed faster. For example, debugging complex validation logic consistently took more time than writing new UI components. Although it was sometimes difficult to remain disciplined about tracking every minute, even partial tracking provided actionable insights for refining estimates and improving project planning. Overall, tracking actual effort was a valuable learning tool for both time management and process improvement.

## How I Recorded My Effort
During Milestone 1, our team tracked effort inconsistently, as we did not establish a clear method at the start of the project. In Milestones 2 and 3, I tracked my effort more consistently by using the timer on my iPhone to record both coding and non-coding activities. I recorded coding tasks such as prompt engineering for AI-generated code, writing and testing functions, and debugging. Non-coding tasks, such as requirement analysis, design planning, and collaboration, were also tracked by noting start and stop times in the issue comments. While the data may not be perfectly precise due to occasional lapses in starting or stopping the timer, I believe it is a reasonably accurate reflection of the time spent on each task.

## Lessons Learned for Better Estimation
In future projects, I would improve my estimation process by:

1. Collecting more reliable historical data from past tasks to inform estimates.  
2. Breaking larger issues into smaller, more manageable subtasks with individual estimates.  
3. Including additional time for debugging, integration, and AI-assisted development.  
4. Using dedicated time-tracking tools for both coding and non-coding tasks to reduce inconsistencies.  

These steps would help create more realistic estimates and more accurate tracking, ultimately improving project planning and execution.

## AI Use in Estimation and Tracking
I utilized AI tools, primarily Copilot in VSCode, for coding tasks. My effort tracking accounted for AI use as follows:

- **Tool:** GitHub Copilot  
- **Coding effort recorded:** Prompt engineering, code generation, verification and debugging, integration/refactoring  
- **Time spent:** Approximately 15â€“20% of coding tasks involved AI assistance, including reviewing and correcting outputs  
- **Portions accepted as-is:** Some boilerplate code and repetitive function implementations were directly usable; more complex logic required manual edits  

Using AI allowed me to accelerate some tasks but also introduced additional effort for verification and integration, which was important to track accurately.

